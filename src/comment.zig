//! Comment Interface (§4.8)
//!
//! This module implements the Comment interface as specified by the WHATWG DOM Standard.
//! Comment nodes represent HTML/XML comments (<!-- comment text -->) in the DOM tree.
//! They are typically used for documentation, debugging output, or conditional content.
//!
//! ## WHATWG Specification
//!
//! Relevant specification sections:
//! - **§4.8 Interface Comment**: https://dom.spec.whatwg.org/#interface-comment
//! - **§4.9 Interface CharacterData**: https://dom.spec.whatwg.org/#interface-characterdata
//! - **§4.4 Interface Node**: https://dom.spec.whatwg.org/#interface-node (base)
//!
//! ## MDN Documentation
//!
//! - Comment: https://developer.mozilla.org/en-US/docs/Web/API/Comment
//! - Comment(): https://developer.mozilla.org/en-US/docs/Web/API/Comment/Comment
//! - Document.createComment(): https://developer.mozilla.org/en-US/docs/Web/API/Document/createComment
//! - Node.nodeType: https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
//!
//! ## Core Features
//!
//! ### Comment Storage
//! Comments store mutable text content, similar to Text nodes:
//! ```zig
//! const comment = try Comment.create(allocator, " This is a comment ");
//! defer comment.prototype.release();
//!
//! // Access via node.nodeValue
//! const content = comment.prototype.nodeValue(); // " This is a comment "
//!
//! // Or via data field
//! const data = comment.data; // " This is a comment "
//! ```
//!
//! ### Character Data Manipulation
//! Comments support the same text manipulation methods as Text nodes:
//! ```zig
//! const comment = try Comment.create(allocator, " TODO ");
//! defer comment.prototype.release();
//!
//! // Append text
//! try comment.appendData("fix this later");
//! // comment.data = " TODO fix this later"
//!
//! // Get substring
//! const sub = try comment.substringData(1, 4); // "TODO"
//! defer allocator.free(sub);
//! ```
//!
//! ### Use Cases
//! Comments are commonly used for:
//! ```zig
//! // 1. Documentation in generated HTML
//! const doc_comment = try Comment.create(allocator, " Page generated at 2025-10-17 ");
//!
//! // 2. Debugging markers
//! const debug_comment = try Comment.create(allocator, " DEBUG: user session active ");
//!
//! // 3. Conditional content (IE conditional comments)
//! const ie_comment = try Comment.create(allocator, "[if IE]><link rel='stylesheet' href='ie.css'><![endif]");
//! ```
//!
//! ## Comment Node Structure
//!
//! Comment nodes are nearly identical to Text nodes in structure:
//! - **node**: Base Node struct (MUST be first field for @fieldParentPtr)
//! - **data**: Owned string ([]u8) containing comment content
//! - **vtable**: Node vtable for polymorphic behavior
//!
//! Size beyond Node: 16 bytes (for data slice)
//!
//! **Key Differences from Text:**
//! - nodeName is "#comment" (vs "#text")
//! - nodeType is .comment (vs .text)
//! - Comments don't affect layout (never rendered)
//! - Comments preserved during serialization
//!
//! ## Memory Management
//!
//! Comment nodes use reference counting through Node interface:
//! ```zig
//! const comment = try Comment.create(allocator, " Note ");
//! defer comment.prototype.release(); // Decrements ref_count, frees if 0
//!
//! // When sharing ownership:
//! comment.prototype.acquire(); // Increment ref_count
//! other_structure.comment_node = &comment.prototype;
//! // Both owners must call release()
//! ```
//!
//! When a comment node is released (ref_count reaches 0):
//! 1. Comment data string is freed (allocator.free(data))
//! 2. Node base is freed
//! 3. Children are released recursively (though comments rarely have children)
//!
//! ## Usage Examples
//!
//! ### Creating Comments
//! ```zig
//! const allocator = std.heap.page_allocator;
//!
//! // Direct creation (simple, for tests)
//! const comment1 = try Comment.create(allocator, " Simple comment ");
//! defer comment1.prototype.release();
//!
//! // Via Document factory (RECOMMENDED)
//! const doc = try Document.init(allocator);
//! defer doc.release();
//! const comment2 = try doc.createComment(" Document comment ");
//! defer comment2.prototype.release();
//! ```
//!
//! ### Adding Comments to DOM
//! ```zig
//! const doc = try Document.init(allocator);
//! defer doc.release();
//!
//! const html = try doc.createElement("html");
//! _ = try doc.prototype.appendChild(&html.prototype);
//!
//! // Add comment at top of document
//! const comment = try doc.createComment(" Generated by MyApp v1.0 ");
//! _ = try html.prototype.insertBefore(&comment.prototype, html.prototype.first_child);
//!
//! // Result: <html><!-- Generated by MyApp v1.0 -->...</html>
//! ```
//!
//! ### Conditional Comments Pattern
//! ```zig
//! fn addIEConditional(parent: *Node, allocator: Allocator) !void {
//!     // Opening conditional comment
//!     const open = try Comment.create(allocator, "[if lt IE 9]>");
//!     _ = try parent.appendChild(&open.prototype);
//!
//!     // Conditional content (script tags, etc.)
//!     const script = try Element.create(allocator, "script");
//!     try script.setAttribute("src", "html5shiv.js");
//!     _ = try parent.appendChild(&script.prototype);
//!
//!     // Closing conditional comment
//!     const close = try Comment.create(allocator, "<![endif]");
//!     _ = try parent.appendChild(&close.prototype);
//! }
//! ```
//!
//! ## Common Patterns
//!
//! ### Stripping Comments
//! ```zig
//! fn stripComments(node: *Node) void {
//!     var current = node.first_child;
//!     while (current) |child| {
//!         const next = child.next_sibling; // Save before potential removal
//!
//!         if (child.node_type == .comment) {
//!             _ = node.removeChild(child) catch {};
//!             child.release();
//!         } else {
//!             stripComments(child); // Recurse
//!         }
//!
//!         current = next;
//!     }
//! }
//! ```
//!
//! ### Finding Comments
//! ```zig
//! fn findCommentsByPrefix(node: *Node, prefix: []const u8, allocator: Allocator) !std.ArrayList(*Comment) {
//!     var results = std.ArrayList(*Comment).init(allocator);
//!
//!     var current = node.first_child;
//!     while (current) |child| : (current = child.next_sibling) {
//!         if (child.node_type == .comment) {
//!             const comment = @fieldParentPtr(Comment, "node", child);
//!             if (std.mem.startsWith(u8, comment.data, prefix)) {
//!                 try results.append(comment);
//!             }
//!         }
//!
//!         // Recurse into children
//!         const child_results = try findCommentsByPrefix(child, prefix, allocator);
//!         defer child_results.deinit();
//!         try results.appendSlice(child_results.items);
//!     }
//!
//!     return results;
//! }
//! ```
//!
//! ## Performance Tips
//!
//! 1. **Strip When Unnecessary** - Remove comments in production builds if not needed
//! 2. **Batch Creation** - Use Document.createComment() for string interning
//! 3. **Avoid Large Comments** - Keep comment text small (not for data storage)
//! 4. **Consider Alternatives** - Data attributes may be better than comment-based metadata
//! 5. **Skip in Traversal** - Most DOM traversals can skip comment nodes safely
//! 6. **Direct Access** - Use comment.data instead of nodeValue() for frequent access
//!
//! ## JavaScript Bindings
//!
//! ### Instance Properties
//! ```javascript
//! // data (read-write) - CharacterData interface
//! Object.defineProperty(Comment.prototype, 'data', {
//!   get: function() { return zig.comment_get_data(this._ptr); },
//!   set: function(value) { zig.comment_set_data(this._ptr, value); }
//! });
//!
//! // length (readonly) - CharacterData interface
//! Object.defineProperty(Comment.prototype, 'length', {
//!   get: function() { return zig.comment_get_length(this._ptr); }
//! });
//!
//! // Comment inherits all Node properties (nodeType, nodeName, nodeValue, etc.)
//! ```
//!
//! ### Instance Methods
//! ```javascript
//! // CharacterData methods
//! Comment.prototype.substringData = function(offset, count) {
//!   return zig.comment_substringData(this._ptr, offset, count);
//! };
//!
//! Comment.prototype.appendData = function(data) {
//!   zig.comment_appendData(this._ptr, data);
//! };
//!
//! Comment.prototype.insertData = function(offset, data) {
//!   zig.comment_insertData(this._ptr, offset, data);
//! };
//!
//! Comment.prototype.deleteData = function(offset, count) {
//!   zig.comment_deleteData(this._ptr, offset, count);
//! };
//!
//! Comment.prototype.replaceData = function(offset, count, data) {
//!   zig.comment_replaceData(this._ptr, offset, count, data);
//! };
//!
//! // Comment inherits all Node methods (appendChild, etc.)
//! // Comment inherits all EventTarget methods (addEventListener, etc.)
//! ```
//!
//! See `JS_BINDINGS.md` for complete binding patterns and memory management.
//!
//! ## Implementation Notes
//!
//! - Comment extends Node via struct embedding (node is first field)
//! - Comment.data is owned by the Comment node (allocated, must be freed)
//! - Node.nodeValue() returns comment.data for comment nodes
//! - Comments are NOT rendered (don't affect layout)
//! - nodeName is always "#comment" for comment nodes
//! - Comment nodes cannot have attributes
//! - Comments are preserved during cloning and serialization
//! - CharacterData methods (appendData, etc.) are on Comment struct directly
//! - Comment nodes rarely have children (but spec allows it)

const std = @import("std");
const Allocator = std.mem.Allocator;
const node_mod = @import("node.zig");
const Node = node_mod.Node;
const NodeType = node_mod.NodeType;
const NodeVTable = node_mod.NodeVTable;

/// Comment node representing HTML/XML comments in the DOM.
///
/// Comment nodes store mutable string content and provide methods for
/// character data manipulation, similar to Text nodes.
///
/// ## Memory Layout
/// - Embeds Node as first field (for vtable polymorphism)
/// - Stores comment data as owned string (allocated)
/// - Comment content can be modified via nodeValue or data accessors
pub const Comment = struct {
    /// Base Node (MUST be first field for @fieldParentPtr to work)
    prototype: Node,

    /// Comment content (owned string, 16 bytes)
    /// Allocated and freed by this Comment node
    data: []u8,

    /// Vtable for Comment nodes.
    const vtable = NodeVTable{
        .deinit = deinitImpl,
        .node_name = nodeNameImpl,
        .node_value = nodeValueImpl,
        .set_node_value = setNodeValueImpl,
        .clone_node = cloneNodeImpl,
        .adopting_steps = adoptingStepsImpl,
    };

    /// Creates a new Comment node with the specified content.
    ///
    /// ## Memory Management
    /// Returns Comment with ref_count=1. Caller MUST call `comment.prototype.release()`.
    /// Comment content is duplicated and owned by the Comment node.
    ///
    /// ## Parameters
    /// - `allocator`: Memory allocator for node creation
    /// - `content`: Initial comment content (will be duplicated)
    ///
    /// ## Returns
    /// New comment node with ref_count=1
    ///
    /// ## Errors
    /// - `error.OutOfMemory`: Failed to allocate memory
    ///
    /// ## Example
    /// ```zig
    /// const comment = try Comment.create(allocator, " TODO: implement this ");
    /// defer comment.prototype.release();
    /// ```
    pub fn create(allocator: Allocator, content: []const u8) !*Comment {
        const comment = try allocator.create(Comment);
        errdefer allocator.destroy(comment);

        // Duplicate comment content (owned by this node)
        const data = try allocator.dupe(u8, content);
        errdefer allocator.free(data);

        // Initialize base Node
        comment.prototype = .{
            .prototype = .{
                .vtable = &node_mod.eventtarget_vtable,
            },
            .vtable = &vtable,
            .ref_count_and_parent = std.atomic.Value(u32).init(1),
            .node_type = .comment,
            .flags = 0,
            .node_id = 0,
            .generation = 0,
            .allocator = allocator,
            .parent_node = null,
            .previous_sibling = null,
            .first_child = null,
            .last_child = null,
            .next_sibling = null,
            .owner_document = null,
            .rare_data = null,
        };

        // Initialize Comment-specific fields
        comment.data = data;

        return comment;
    }

    /// Returns the comment content length in bytes.
    pub fn length(self: *const Comment) usize {
        return self.data.len;
    }

    /// Returns a substring of the comment content.
    ///
    /// ## Parameters
    /// - `allocator`: Allocator for substring
    /// - `offset`: Starting byte offset
    /// - `count`: Number of bytes (or null for rest of string)
    ///
    /// ## Returns
    /// Owned string slice. Caller must free with allocator.
    ///
    /// ## Errors
    /// - `error.OutOfMemory`: Failed to allocate substring
    /// - `error.IndexOutOfBounds`: Offset exceeds data length
    pub fn substringData(
        self: *const Comment,
        allocator: Allocator,
        offset: usize,
        count: ?usize,
    ) ![]u8 {
        if (offset > self.data.len) {
            return error.IndexOutOfBounds;
        }

        const end = if (count) |c|
            @min(offset + c, self.data.len)
        else
            self.data.len;

        return allocator.dupe(u8, self.data[offset..end]);
    }

    /// Appends text to the end of the comment.
    ///
    /// ## Parameters
    /// - `text_to_append`: Text to append
    ///
    /// ## Errors
    /// - `error.OutOfMemory`: Failed to allocate new string
    pub fn appendData(self: *Comment, text_to_append: []const u8) !void {
        const new_data = try std.mem.concat(
            self.prototype.allocator,
            u8,
            &[_][]const u8{ self.data, text_to_append },
        );

        self.prototype.allocator.free(self.data);
        self.data = new_data;
        self.prototype.generation += 1;
    }

    /// Inserts text at the specified offset.
    ///
    /// ## Parameters
    /// - `offset`: Byte offset where to insert
    /// - `text_to_insert`: Text to insert
    ///
    /// ## Errors
    /// - `error.OutOfMemory`: Failed to allocate new string
    /// - `error.IndexOutOfBounds`: Offset exceeds data length
    pub fn insertData(self: *Comment, offset: usize, text_to_insert: []const u8) !void {
        if (offset > self.data.len) {
            return error.IndexOutOfBounds;
        }

        const new_data = try std.mem.concat(
            self.prototype.allocator,
            u8,
            &[_][]const u8{ self.data[0..offset], text_to_insert, self.data[offset..] },
        );

        self.prototype.allocator.free(self.data);
        self.data = new_data;
        self.prototype.generation += 1;
    }

    /// Deletes text at the specified offset.
    ///
    /// ## Parameters
    /// - `offset`: Starting byte offset
    /// - `count`: Number of bytes to delete
    ///
    /// ## Errors
    /// - `error.OutOfMemory`: Failed to allocate new string
    /// - `error.IndexOutOfBounds`: Offset exceeds data length
    pub fn deleteData(self: *Comment, offset: usize, count: usize) !void {
        if (offset > self.data.len) {
            return error.IndexOutOfBounds;
        }

        const end = @min(offset + count, self.data.len);

        const new_data = try std.mem.concat(
            self.prototype.allocator,
            u8,
            &[_][]const u8{ self.data[0..offset], self.data[end..] },
        );

        self.prototype.allocator.free(self.data);
        self.data = new_data;
        self.prototype.generation += 1;
    }

    /// Replaces text at the specified offset.
    ///
    /// ## Parameters
    /// - `offset`: Starting byte offset
    /// - `count`: Number of bytes to replace
    /// - `replacement`: Replacement text
    ///
    /// ## Errors
    /// - `error.OutOfMemory`: Failed to allocate new string
    /// - `error.IndexOutOfBounds`: Offset exceeds data length
    pub fn replaceData(
        self: *Comment,
        offset: usize,
        count: usize,
        replacement: []const u8,
    ) !void {
        if (offset > self.data.len) {
            return error.IndexOutOfBounds;
        }

        const end = @min(offset + count, self.data.len);

        const new_data = try std.mem.concat(
            self.prototype.allocator,
            u8,
            &[_][]const u8{ self.data[0..offset], replacement, self.data[end..] },
        );

        self.prototype.allocator.free(self.data);
        self.data = new_data;
        self.prototype.generation += 1;
    }

    // ========================================================================
    // NonDocumentTypeChildNode Mixin (WHATWG DOM §4.2.7)
    // ========================================================================

    /// Returns the previous sibling that is an element.
    ///
    /// Implements WHATWG DOM NonDocumentTypeChildNode.previousElementSibling property.
    ///
    /// ## WebIDL
    /// ```webidl
    /// readonly attribute Element? previousElementSibling;
    /// ```
    ///
    /// ## MDN Documentation
    /// - previousElementSibling: https://developer.mozilla.org/en-US/docs/Web/API/CharacterData/previousElementSibling
    ///
    /// ## Algorithm (from spec §4.2.7)
    /// Return the first preceding sibling of this that is an element, or null if there is no such sibling.
    ///
    /// ## Spec References
    /// - Algorithm: https://dom.spec.whatwg.org/#dom-nondocumenttypechildnode-previouselementsibling
    /// - WebIDL: dom.idl:138
    ///
    /// ## Returns
    /// Previous element sibling or null
    ///
    /// ## Example
    /// ```zig
    /// const parent = try doc.createElement("parent");
    /// const elem = try doc.createElement("child");
    /// _ = try parent.prototype.appendChild(&elem.prototype);
    /// const comment = try doc.createComment("note");
    /// _ = try parent.prototype.appendChild(&comment.prototype);
    ///
    /// // comment.previousElementSibling() returns elem
    /// try std.testing.expect(comment.previousElementSibling() == elem);
    /// ```
    pub fn previousElementSibling(self: *const Comment) ?*@import("element.zig").Element {
        var current = self.prototype.previous_sibling;
        while (current) |sibling| {
            if (sibling.node_type == .element) {
                return @fieldParentPtr("prototype", sibling);
            }
            current = sibling.previous_sibling;
        }
        return null;
    }

    /// Returns the next sibling that is an element.
    ///
    /// Implements WHATWG DOM NonDocumentTypeChildNode.nextElementSibling property.
    ///
    /// ## WebIDL
    /// ```webidl
    /// readonly attribute Element? nextElementSibling;
    /// ```
    ///
    /// ## MDN Documentation
    /// - nextElementSibling: https://developer.mozilla.org/en-US/docs/Web/API/CharacterData/nextElementSibling
    ///
    /// ## Algorithm (from spec §4.2.7)
    /// Return the first following sibling of this that is an element, or null if there is no such sibling.
    ///
    /// ## Spec References
    /// - Algorithm: https://dom.spec.whatwg.org/#dom-nondocumenttypechildnode-nextelementsibling
    /// - WebIDL: dom.idl:139
    ///
    /// ## Returns
    /// Next element sibling or null
    ///
    /// ## Example
    /// ```zig
    /// const parent = try doc.createElement("parent");
    /// const comment = try doc.createComment("note");
    /// _ = try parent.prototype.appendChild(&comment.prototype);
    /// const elem = try doc.createElement("child");
    /// _ = try parent.prototype.appendChild(&elem.prototype);
    ///
    /// // comment.nextElementSibling() returns elem
    /// try std.testing.expect(comment.nextElementSibling() == elem);
    /// ```
    pub fn nextElementSibling(self: *const Comment) ?*@import("element.zig").Element {
        var current = self.prototype.next_sibling;
        while (current) |sibling| {
            if (sibling.node_type == .element) {
                return @fieldParentPtr("prototype", sibling);
            }
            current = sibling.next_sibling;
        }
        return null;
    }

    // ========================================================================
    // ChildNode Mixin (WHATWG DOM §4.2.8)
    // ========================================================================

    /// NodeOrString union for ChildNode variadic methods.
    ///
    /// Represents the WebIDL `(Node or DOMString)` union type.
    pub const NodeOrString = union(enum) {
        node: *Node,
        string: []const u8,
    };

    /// Removes this comment node from its parent.
    ///
    /// Implements WHATWG DOM ChildNode.remove() per §4.2.8.
    ///
    /// ## WebIDL
    /// ```webidl
    /// [CEReactions, Unscopable] undefined remove();
    /// ```
    ///
    /// ## MDN Documentation
    /// - remove(): https://developer.mozilla.org/en-US/docs/Web/API/CharacterData/remove
    ///
    /// ## Algorithm (from spec §4.2.8)
    /// If this's parent is null, return. Otherwise, remove this from its parent.
    ///
    /// ## Spec References
    /// - Algorithm: https://dom.spec.whatwg.org/#dom-childnode-remove
    /// - WebIDL: dom.idl:148
    pub fn remove(self: *Comment) !void {
        if (self.prototype.parent_node) |parent| {
            _ = try parent.removeChild(&self.prototype);
        }
    }

    /// Inserts nodes before this comment node.
    ///
    /// Implements WHATWG DOM ChildNode.before() per §4.2.8.
    ///
    /// ## WebIDL
    /// ```webidl
    /// [CEReactions, Unscopable] undefined before((Node or DOMString)... nodes);
    /// ```
    ///
    /// ## MDN Documentation
    /// - before(): https://developer.mozilla.org/en-US/docs/Web/API/CharacterData/before
    ///
    /// ## Spec References
    /// - Algorithm: https://dom.spec.whatwg.org/#dom-childnode-before
    /// - WebIDL: dom.idl:145
    pub fn before(self: *Comment, nodes: []const NodeOrString) !void {
        const parent = self.prototype.parent_node orelse return;

        const result = try convertNodesToNode(&self.prototype, nodes);
        if (result == null) return;

        const node_to_insert = result.?.node;
        const should_release = result.?.should_release_after_insert;

        const returned_node = try parent.insertBefore(node_to_insert, &self.prototype);

        if (should_release) {
            returned_node.release();
        }
    }

    /// Inserts nodes after this comment node.
    ///
    /// Implements WHATWG DOM ChildNode.after() per §4.2.8.
    ///
    /// ## WebIDL
    /// ```webidl
    /// [CEReactions, Unscopable] undefined after((Node or DOMString)... nodes);
    /// ```
    ///
    /// ## MDN Documentation
    /// - after(): https://developer.mozilla.org/en-US/docs/Web/API/CharacterData/after
    ///
    /// ## Spec References
    /// - Algorithm: https://dom.spec.whatwg.org/#dom-childnode-after
    /// - WebIDL: dom.idl:146
    pub fn after(self: *Comment, nodes: []const NodeOrString) !void {
        const parent = self.prototype.parent_node orelse return;

        const result = try convertNodesToNode(&self.prototype, nodes);
        if (result == null) return;

        const node_to_insert = result.?.node;
        const should_release = result.?.should_release_after_insert;

        const returned_node = try parent.insertBefore(node_to_insert, self.prototype.next_sibling);

        if (should_release) {
            returned_node.release();
        }
    }

    /// Replaces this comment node with other nodes.
    ///
    /// Implements WHATWG DOM ChildNode.replaceWith() per §4.2.8.
    ///
    /// ## WebIDL
    /// ```webidl
    /// [CEReactions, Unscopable] undefined replaceWith((Node or DOMString)... nodes);
    /// ```
    ///
    /// ## MDN Documentation
    /// - replaceWith(): https://developer.mozilla.org/en-US/docs/Web/API/CharacterData/replaceWith
    ///
    /// ## Spec References
    /// - Algorithm: https://dom.spec.whatwg.org/#dom-childnode-replacewith
    /// - WebIDL: dom.idl:147
    pub fn replaceWith(self: *Comment, nodes: []const NodeOrString) !void {
        const parent = self.prototype.parent_node orelse return;

        const result = try convertNodesToNode(&self.prototype, nodes);

        if (result) |r| {
            _ = try parent.replaceChild(r.node, &self.prototype);
            if (r.should_release_after_insert) {
                r.prototype.release();
            }
        } else {
            _ = try parent.removeChild(&self.prototype);
        }
    }

    /// Result of converting nodes/strings
    const ConvertResult = struct {
        node: *Node,
        should_release_after_insert: bool,
    };

    /// Helper: Convert slice of nodes/strings into a single node.
    fn convertNodesToNode(parent: *Node, items: []const NodeOrString) !?ConvertResult {
        if (items.len == 0) return null;

        const owner_doc = parent.owner_document orelse {
            return error.InvalidStateError;
        };

        const Document = @import("document.zig").Document;
        if (owner_doc.node_type != .document) {
            return error.InvalidStateError;
        }
        const doc: *Document = @fieldParentPtr("prototype", owner_doc);

        if (items.len == 1) {
            switch (items[0]) {
                .node => |n| {
                    return ConvertResult{
                        .node = n,
                        .should_release_after_insert = false,
                    };
                },
                .string => |s| {
                    const text = try doc.createTextNode(s);
                    return ConvertResult{
                        .node = &text.prototype,
                        .should_release_after_insert = false,
                    };
                },
            }
        }

        const fragment = try doc.createDocumentFragment();
        errdefer fragment.prototype.release();

        for (items) |item| {
            switch (item) {
                .node => |n| {
                    _ = try fragment.prototype.appendChild(n);
                },
                .string => |s| {
                    const text = try doc.createTextNode(s);
                    _ = try fragment.prototype.appendChild(&text.prototype);
                },
            }
        }

        return ConvertResult{
            .node = &fragment.prototype,
            .should_release_after_insert = true,
        };
    }

    // === Private vtable implementations ===

    /// Vtable implementation: adopting steps (no-op for Comment)
    ///
    /// Comment nodes own their data, so no re-interning is needed during adoption.
    fn adoptingStepsImpl(_: *Node, _: ?*Node) !void {
        // No-op: Comment data is already owned by the node
    }

    /// Vtable implementation: cleanup
    fn deinitImpl(node: *Node) void {
        const comment: *Comment = @fieldParentPtr("prototype", node);

        // Release document reference if owned by a document
        if (comment.prototype.owner_document) |owner_doc| {
            if (owner_doc.node_type == .document) {
                // Get Document from its node field (node is first field)
                const Document = @import("document.zig").Document;
                const doc: *Document = @fieldParentPtr("prototype", owner_doc);
                doc.releaseNodeRef();
            }
        }

        // Clean up rare data if allocated
        comment.prototype.deinitRareData();

        comment.prototype.allocator.free(comment.data);
        comment.prototype.allocator.destroy(comment);
    }

    /// Vtable implementation: node name (always "#comment")
    fn nodeNameImpl(_: *const Node) []const u8 {
        return "#comment";
    }

    /// Vtable implementation: node value (returns comment content)
    fn nodeValueImpl(node: *const Node) ?[]const u8 {
        const comment: *const Comment = @fieldParentPtr("prototype", node);
        return comment.data;
    }

    /// Vtable implementation: set node value (updates comment content)
    fn setNodeValueImpl(node: *Node, value: []const u8) !void {
        const comment: *Comment = @fieldParentPtr("prototype", node);

        // Allocate new content
        const new_data = try node.allocator.dupe(u8, value);

        // Free old and replace
        node.allocator.free(comment.data);
        comment.data = new_data;
        node.generation += 1;
    }

    /// Vtable implementation: clone node
    fn cloneNodeImpl(node: *const Node, deep: bool) !*Node {
        const comment: *const Comment = @fieldParentPtr("prototype", node);

        // Comment nodes have no children, so deep is ignored
        _ = deep;

        // Create new comment with same content
        const cloned = try Comment.create(node.allocator, comment.data);

        // Preserve owner document (WHATWG DOM §4.5.1 Clone algorithm)
        cloned.prototype.owner_document = comment.prototype.owner_document;

        return &cloned.prototype;
    }
};

// ============================================================================
// TESTS
// ============================================================================

test "Comment - creation and cleanup" {
    const allocator = std.testing.allocator;

    const comment = try Comment.create(allocator, " TODO: implement ");
    defer comment.prototype.release();

    // Verify node properties
    try std.testing.expectEqual(NodeType.comment, comment.prototype.node_type);
    try std.testing.expectEqual(@as(u32, 1), comment.prototype.getRefCount());
    try std.testing.expectEqualStrings(" TODO: implement ", comment.data);
    try std.testing.expectEqual(@as(usize, 17), comment.length());

    // Verify vtable dispatch
    try std.testing.expectEqualStrings("#comment", comment.prototype.nodeName());
    try std.testing.expectEqualStrings(" TODO: implement ", comment.prototype.nodeValue().?);
}

test "Comment - empty content" {
    const allocator = std.testing.allocator;

    const comment = try Comment.create(allocator, "");
    defer comment.prototype.release();

    try std.testing.expectEqual(@as(usize, 0), comment.length());
    try std.testing.expectEqualStrings("", comment.data);
}

test "Comment - set node value" {
    const allocator = std.testing.allocator;

    const comment = try Comment.create(allocator, " original ");
    defer comment.prototype.release();

    try std.testing.expectEqualStrings(" original ", comment.data);

    // Change via nodeValue setter
    try comment.prototype.setNodeValue(" updated ");
    try std.testing.expectEqualStrings(" updated ", comment.data);

    // Verify generation incremented
    try std.testing.expect(comment.prototype.generation > 0);
}

test "Comment - character data operations" {
    const allocator = std.testing.allocator;

    const comment = try Comment.create(allocator, " TODO");
    defer comment.prototype.release();

    // Append
    try comment.appendData(" fix this");
    try std.testing.expectEqualStrings(" TODO fix this", comment.data);

    // Insert
    try comment.insertData(5, ":");
    try std.testing.expectEqualStrings(" TODO: fix this", comment.data);
    // Now: " TODO: fix this" (15 chars)
    //      0123456789...

    // Replace " fix this" (9 chars starting at pos 6) with " done!"
    try comment.replaceData(6, 9, " done!");
    try std.testing.expectEqualStrings(" TODO: done!", comment.data);
    // Now: " TODO: done!" (12 chars)

    // Delete " done" (5 chars starting at pos 6)
    try comment.deleteData(6, 5);
    try std.testing.expectEqualStrings(" TODO:!", comment.data);
}

test "Comment - substringData" {
    const allocator = std.testing.allocator;

    const comment = try Comment.create(allocator, " Hello World ");
    defer comment.prototype.release();

    // Substring with count
    {
        const sub = try comment.substringData(allocator, 1, 5);
        defer allocator.free(sub);
        try std.testing.expectEqualStrings("Hello", sub);
    }

    // Substring to end
    {
        const sub = try comment.substringData(allocator, 7, null);
        defer allocator.free(sub);
        try std.testing.expectEqualStrings("World ", sub);
    }

    // Out of bounds
    try std.testing.expectError(
        error.IndexOutOfBounds,
        comment.substringData(allocator, 100, 1),
    );
}

test "Comment - cloneNode" {
    const allocator = std.testing.allocator;

    const comment = try Comment.create(allocator, " Original comment ");
    defer comment.prototype.release();

    // Clone
    const cloned_node = try comment.prototype.cloneNode(false);
    defer cloned_node.release();

    const cloned: *Comment = @fieldParentPtr("prototype", cloned_node);

    // Verify clone properties
    try std.testing.expectEqualStrings(" Original comment ", cloned.data);
    try std.testing.expectEqual(@as(u32, 1), cloned.prototype.getRefCount());

    // Verify independence
    try comment.appendData("!");
    try std.testing.expectEqualStrings(" Original comment !", comment.data);
    try std.testing.expectEqualStrings(" Original comment ", cloned.data); // Unchanged
}

test "Comment - memory leak test" {
    const allocator = std.testing.allocator;

    // Test 1: Simple creation
    {
        const comment = try Comment.create(allocator, " test ");
        defer comment.prototype.release();
    }

    // Test 2: Modifications
    {
        const comment = try Comment.create(allocator, " test ");
        defer comment.prototype.release();

        try comment.appendData("more");
        try comment.insertData(0, "prefix ");
        try comment.deleteData(0, 7);
        try comment.replaceData(0, 4, "TEST");
        try comment.prototype.setNodeValue(" final ");
    }

    // Test 3: Clone
    {
        const comment = try Comment.create(allocator, " original ");
        defer comment.prototype.release();

        const cloned = try comment.prototype.cloneNode(false);
        defer cloned.release();
    }

    // Test 4: Multiple acquire/release
    {
        const comment = try Comment.create(allocator, " test ");
        defer comment.prototype.release();

        comment.prototype.acquire();
        defer comment.prototype.release();
    }

    // If we reach here without leaks, std.testing.allocator validates success
}

test "Comment - ref counting" {
    const allocator = std.testing.allocator;

    const comment = try Comment.create(allocator, " test ");
    defer comment.prototype.release();

    // Initial ref count
    try std.testing.expectEqual(@as(u32, 1), comment.prototype.getRefCount());

    // Acquire
    comment.prototype.acquire();
    try std.testing.expectEqual(@as(u32, 2), comment.prototype.getRefCount());

    // Release
    comment.prototype.release();
    try std.testing.expectEqual(@as(u32, 1), comment.prototype.getRefCount());
}
