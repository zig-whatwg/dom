//! Event Interface (ยง2.2)
//!
//! This module implements the Event interface as specified by the WHATWG DOM Standard.
//! Events are the primary mechanism for communicating occurrences in the DOM, from user
//! interactions (clicks, key presses) to document lifecycle events (load, unload) and
//! custom application events.
//!
//! ## WHATWG Specification
//!
//! Relevant specification sections:
//! - **ยง2.2 Interface Event**: https://dom.spec.whatwg.org/#interface-event
//! - **ยง2.3 Legacy Event Initializers**: https://dom.spec.whatwg.org/#legacy-event-initializers
//! - **ยง2.10 Dispatching Events**: https://dom.spec.whatwg.org/#dispatching-events
//!
//! ## MDN Documentation
//!
//! - Event: https://developer.mozilla.org/en-US/docs/Web/API/Event
//! - Event.type: https://developer.mozilla.org/en-US/docs/Web/API/Event/type
//! - Event.target: https://developer.mozilla.org/en-US/docs/Web/API/Event/target
//! - Event.preventDefault(): https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault
//! - Event.stopPropagation(): https://developer.mozilla.org/en-US/docs/Web/API/Event/stopPropagation
//! - Event.eventPhase: https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase
//!
//! ## Core Features
//!
//! ### Event Phases
//! Events propagate through the DOM tree in three phases:
//! ```zig
//! const event = Event.init("click", .{ .bubbles = true, .cancelable = true, .composed = false });
//! // Phase 1: CAPTURING_PHASE - From window down to target
//! // Phase 2: AT_TARGET - At the event target itself
//! // Phase 3: BUBBLING_PHASE - From target back up to window (if bubbles = true)
//! ```
//!
//! ### Propagation Control
//! Events can be stopped at any point during propagation:
//! ```zig
//! var event = Event.init("click", .{ .bubbles = true, .cancelable = true, .composed = false });
//! event.stopPropagation(); // Stops after current target
//! event.stopImmediatePropagation(); // Stops immediately, other listeners won't fire
//! ```
//!
//! ### Default Action Prevention
//! Cancelable events can have their default action prevented:
//! ```zig
//! var event = Event.init("submit", .{ .bubbles = true, .cancelable = true, .composed = false });
//! event.preventDefault(); // Cancels default form submission
//! const was_cancelled = event.defaultPrevented(); // true
//! ```
//!
//! ## Event Structure
//!
//! The Event struct contains both public attributes (matching WebIDL) and internal flags
//! (used by the dispatch algorithm):
//!
//! **Public Attributes:**
//! - `event_type` - Event type string (e.g., "click", "load")
//! - `target` - Original event target
//! - `current_target` - Current target in propagation path
//! - `event_phase` - Current phase (none, capturing, at_target, bubbling)
//! - `bubbles` - Whether event bubbles up the tree
//! - `cancelable` - Whether preventDefault() can cancel default action
//! - `is_trusted` - True if generated by user agent, false if via dispatchEvent()
//! - `time_stamp` - Event creation timestamp
//! - `composed` - Whether event crosses shadow DOM boundaries
//!
//! **Internal Flags (WHATWG):**
//! - `stop_propagation_flag` - Set by stopPropagation()
//! - `stop_immediate_propagation_flag` - Set by stopImmediatePropagation()
//! - `canceled_flag` - Set by preventDefault()
//! - `in_passive_listener_flag` - Set when in passive listener
//! - `dispatch_flag` - Set while event is being dispatched
//! - `initialized_flag` - Set when event is properly initialized
//!
//! ## Memory Management
//!
//! Events are typically stack-allocated values that don't require cleanup:
//! ```zig
//! const event = Event.init("click", .{ .bubbles = true, .cancelable = true, .composed = false });
//! // No defer needed - Event is a plain struct
//! ```
//!
//! For heap allocation (if needed):
//! ```zig
//! const allocator = std.heap.page_allocator;
//! const event = try allocator.create(Event);
//! defer allocator.destroy(event);
//! event.* = Event.init("load", .{ .bubbles = false, .cancelable = false, .composed = false });
//! ```
//!
//! ## Usage Examples
//!
//! ### Creating and Dispatching Events
//! ```zig
//! const allocator = std.testing.allocator;
//!
//! // Create event target
//! const target = try EventTarget.init(allocator);
//! defer target.deinit();
//!
//! // Create event
//! var event = Event.init("custom-event", .{
//!     .bubbles = true,
//!     .cancelable = true,
//!     .composed = false,
//! });
//!
//! // Dispatch (EventTarget handles propagation)
//! try target.dispatchEvent(&event);
//! ```
//!
//! ### Preventing Default Actions
//! ```zig
//! var submit_event = Event.init("submit", .{
//!     .bubbles = true,
//!     .cancelable = true,
//!     .composed = false,
//! });
//!
//! // In event listener
//! submit_event.preventDefault();
//!
//! // Check if default was prevented
//! if (submit_event.defaultPrevented()) {
//!     // Default form submission was cancelled
//! }
//! ```
//!
//! ### Controlling Propagation
//! ```zig
//! var event = Event.init("click", .{ .bubbles = true, .cancelable = false, .composed = false });
//!
//! // Stop propagation to other targets
//! event.stopPropagation();
//! // stop_propagation_flag = true
//!
//! // OR stop immediately (other listeners on current target won't fire)
//! event.stopImmediatePropagation();
//! // stop_propagation_flag = true
//! // stop_immediate_propagation_flag = true
//! ```
//!
//! ## Common Patterns
//!
//! ### Event Type Constants
//! ```zig
//! // Define common event types as constants
//! pub const EventTypes = struct {
//!     pub const CLICK = "click";
//!     pub const LOAD = "load";
//!     pub const SUBMIT = "submit";
//!     pub const KEYDOWN = "keydown";
//! };
//!
//! const event = Event.init(EventTypes.CLICK, .{ .bubbles = true, .cancelable = true, .composed = false });
//! ```
//!
//! ### Checking Event Phase
//! ```zig
//! fn handleEvent(event: *Event) void {
//!     switch (event.event_phase) {
//!         .capturing_phase => {
//!             // Handle during capture
//!         },
//!         .at_target => {
//!             // Handle at target
//!         },
//!         .bubbling_phase => {
//!             // Handle during bubble
//!         },
//!         .none => {
//!             // Not currently dispatching
//!         },
//!     }
//! }
//! ```
//!
//! ## Performance Tips
//!
//! 1. **Stack Allocate Events** - Events are plain structs, prefer stack allocation over heap
//! 2. **Reuse Event Objects** - Reset internal flags instead of creating new events
//! 3. **Early Exit on stopImmediatePropagation** - Check flag before invoking listeners
//! 4. **Passive Listeners** - Use `in_passive_listener_flag` for performance-critical scroll/touch events
//! 5. **Minimize Event Creation** - Only create events when they'll actually be dispatched
//! 6. **String Interning** - Use interned event type strings when using Document factory
//! 7. **Avoid Heap Allocation** - Stack-allocated events avoid allocation overhead
//!
//! ## JavaScript Bindings
//!
//! ### Event Constructor
//! ```javascript
//! // Create new event with options
//! const event = new Event('click', {
//!   bubbles: true,
//!   cancelable: true,
//!   composed: false
//! });
//!
//! // In bindings implementation:
//! function Event(type, eventInitDict) {
//!   const opts = eventInitDict || {};
//!   this._ptr = zig.event_init(
//!     type,
//!     opts.bubbles || false,
//!     opts.cancelable || false,
//!     opts.composed || false
//!   );
//! }
//! ```
//!
//! ### Instance Properties
//! ```javascript
//! // type (readonly)
//! Object.defineProperty(Event.prototype, 'type', {
//!   get: function() { return zig.event_get_type(this._ptr); }
//! });
//!
//! // target (readonly)
//! Object.defineProperty(Event.prototype, 'target', {
//!   get: function() { return zig.event_get_target(this._ptr); }
//! });
//!
//! // currentTarget (readonly)
//! Object.defineProperty(Event.prototype, 'currentTarget', {
//!   get: function() { return zig.event_get_current_target(this._ptr); }
//! });
//!
//! // eventPhase (readonly)
//! Object.defineProperty(Event.prototype, 'eventPhase', {
//!   get: function() { return zig.event_get_event_phase(this._ptr); }
//! });
//!
//! // bubbles (readonly)
//! Object.defineProperty(Event.prototype, 'bubbles', {
//!   get: function() { return zig.event_get_bubbles(this._ptr); }
//! });
//!
//! // cancelable (readonly)
//! Object.defineProperty(Event.prototype, 'cancelable', {
//!   get: function() { return zig.event_get_cancelable(this._ptr); }
//! });
//!
//! // defaultPrevented (readonly)
//! Object.defineProperty(Event.prototype, 'defaultPrevented', {
//!   get: function() { return zig.event_get_default_prevented(this._ptr); }
//! });
//!
//! // composed (readonly)
//! Object.defineProperty(Event.prototype, 'composed', {
//!   get: function() { return zig.event_get_composed(this._ptr); }
//! });
//!
//! // isTrusted (readonly)
//! Object.defineProperty(Event.prototype, 'isTrusted', {
//!   get: function() { return zig.event_get_is_trusted(this._ptr); }
//! });
//!
//! // timeStamp (readonly)
//! Object.defineProperty(Event.prototype, 'timeStamp', {
//!   get: function() { return zig.event_get_time_stamp(this._ptr); }
//! });
//! ```
//!
//! ### Instance Methods
//! ```javascript
//! Event.prototype.stopPropagation = function() {
//!   zig.event_stopPropagation(this._ptr);
//! };
//!
//! Event.prototype.stopImmediatePropagation = function() {
//!   zig.event_stopImmediatePropagation(this._ptr);
//! };
//!
//! Event.prototype.preventDefault = function() {
//!   zig.event_preventDefault(this._ptr);
//! };
//! ```
//!
//! ### Event Phase Constants
//! ```javascript
//! Event.NONE = 0;
//! Event.CAPTURING_PHASE = 1;
//! Event.AT_TARGET = 2;
//! Event.BUBBLING_PHASE = 3;
//! ```
//!
//! See `JS_BINDINGS.md` for complete binding patterns and memory management.
//!
//! ## Implementation Notes
//!
//! - Event is a plain struct (no reference counting needed)
//! - Internal flags follow WHATWG spec naming exactly
//! - `target` and `current_target` use `*anyopaque` for type flexibility
//! - `time_stamp` is f64 to match DOMHighResTimeStamp (milliseconds since time origin)
//! - `event_phase` uses enum(u16) to match WebIDL unsigned short
//! - `is_trusted` defaults to false (set to true by user agent, not dispatchEvent)
//! - All methods match WebIDL signatures (undefined โ void, boolean โ bool)

const std = @import("std");
const Allocator = std.mem.Allocator;

pub const Event = struct {
    /// Event type (e.g., "click", "load", "submit")
    event_type: []const u8,

    /// Target to which event is dispatched
    target: ?*anyopaque = null,

    /// Current target whose event listener is being invoked
    current_target: ?*anyopaque = null,

    /// Event phase (NONE, CAPTURING_PHASE, AT_TARGET, BUBBLING_PHASE)
    event_phase: EventPhase = .none,

    /// Whether event bubbles up the tree
    bubbles: bool,

    /// Whether event can be canceled
    cancelable: bool,

    /// Whether event was generated by user agent (vs dispatchEvent)
    is_trusted: bool = false,

    /// Timestamp when event was created (milliseconds)
    time_stamp: f64 = 0.0,

    /// Whether event invokes listeners past ShadowRoot boundary
    composed: bool = false,

    // Internal flags (not exposed as attributes)

    /// Stop propagation flag - prevents event from reaching other objects
    stop_propagation_flag: bool = false,

    /// Stop immediate propagation flag - prevents other listeners from being invoked
    stop_immediate_propagation_flag: bool = false,

    /// Canceled flag - set by preventDefault()
    canceled_flag: bool = false,

    /// In passive listener flag - used for performance optimizations
    in_passive_listener_flag: bool = false,

    /// Dispatch flag - set while event is being dispatched
    dispatch_flag: bool = false,

    /// Initialized flag - set when event is properly initialized
    initialized_flag: bool = false,

    /// Event path - computed during dispatch for composedPath()
    /// Per WHATWG ยง2.9: The event path is a list of objects on which listeners will be invoked
    /// This is populated during dispatch and exposed via composedPath()
    event_path: ?std.ArrayList(*anyopaque) = null,

    /// Event phase constants (WHATWG DOM ยง2.2)
    pub const EventPhase = enum(u16) {
        none = 0,
        capturing_phase = 1,
        at_target = 2,
        bubbling_phase = 3,
    };

    /// Creates a new Event with the given type and options.
    ///
    /// Implements WHATWG DOM Event() constructor per ยง2.2.
    ///
    /// ## WebIDL
    /// ```webidl
    /// constructor(DOMString type, optional EventInit eventInitDict = {});
    /// ```
    ///
    /// ## Parameters
    /// - `event_type`: The event type string (e.g., "click")
    /// - `options`: Optional initialization options
    ///
    /// ## Returns
    /// New Event object
    ///
    /// ## Spec References
    /// - Algorithm: https://dom.spec.whatwg.org/#dom-event-event
    /// - WebIDL: /Users/bcardarella/projects/webref/ed/idl/dom.idl:27
    pub fn init(event_type: []const u8, options: EventInit) Event {
        return .{
            .event_type = event_type,
            .bubbles = options.bubbles,
            .cancelable = options.cancelable,
            .composed = options.composed,
            .initialized_flag = true,
        };
    }

    /// Stops propagation of the event to other objects.
    ///
    /// Implements WHATWG DOM Event.stopPropagation() per ยง2.2.
    ///
    /// ## WebIDL
    /// ```webidl
    /// undefined stopPropagation();
    /// ```
    ///
    /// ## Spec References
    /// - Algorithm: https://dom.spec.whatwg.org/#dom-event-stoppropagation
    /// - WebIDL: /Users/bcardarella/projects/webref/ed/idl/dom.idl:38
    pub fn stopPropagation(self: *Event) void {
        self.stop_propagation_flag = true;
    }

    /// Stops propagation and prevents any remaining listeners from being called.
    ///
    /// Implements WHATWG DOM Event.stopImmediatePropagation() per ยง2.2.
    ///
    /// ## WebIDL
    /// ```webidl
    /// undefined stopImmediatePropagation();
    /// ```
    ///
    /// ## Spec References
    /// - Algorithm: https://dom.spec.whatwg.org/#dom-event-stopimmediatepropagation
    /// - WebIDL: /Users/bcardarella/projects/webref/ed/idl/dom.idl:40
    pub fn stopImmediatePropagation(self: *Event) void {
        self.stop_propagation_flag = true;
        self.stop_immediate_propagation_flag = true;
    }

    /// Cancels the event if it is cancelable.
    ///
    /// Implements WHATWG DOM Event.preventDefault() per ยง2.2.
    ///
    /// ## WebIDL
    /// ```webidl
    /// undefined preventDefault();
    /// ```
    ///
    /// ## Algorithm
    /// Per spec: "To set the canceled flag, given an event, if event's cancelable
    /// attribute value is true and event's in passive listener flag is unset,
    /// then set event's canceled flag."
    ///
    /// ## Spec References
    /// - Algorithm: https://dom.spec.whatwg.org/#dom-event-preventdefault
    /// - WebIDL: /Users/bcardarella/projects/webref/ed/idl/dom.idl:46
    pub fn preventDefault(self: *Event) void {
        // Only cancel if event is cancelable and not in passive listener
        if (self.cancelable and !self.in_passive_listener_flag) {
            self.canceled_flag = true;
        }
    }

    /// Returns whether preventDefault() was successfully invoked.
    ///
    /// Implements WHATWG DOM Event.defaultPrevented getter per ยง2.2.
    ///
    /// ## WebIDL
    /// ```webidl
    /// readonly attribute boolean defaultPrevented;
    /// ```
    ///
    /// ## Spec References
    /// - Algorithm: https://dom.spec.whatwg.org/#dom-event-defaultprevented
    /// - WebIDL: /Users/bcardarella/projects/webref/ed/idl/dom.idl:47
    pub fn defaultPrevented(self: *const Event) bool {
        return self.canceled_flag;
    }

    /// Returns the event's path (list of objects on which listeners will be invoked).
    ///
    /// Implements WHATWG DOM Event.composedPath() per ยง2.9.
    ///
    /// ## WebIDL
    /// ```webidl
    /// sequence<EventTarget> composedPath();
    /// ```
    ///
    /// ## Algorithm (WHATWG DOM ยง2.9)
    /// 1. Let composedPath be an empty list
    /// 2. Let path be event's path (computed during dispatch)
    /// 3. If path is empty, return composedPath
    /// 4. Let currentTarget be event's currentTarget
    /// 5. Append objects from path to composedPath, respecting shadow boundaries
    /// 6. Return composedPath
    ///
    /// ## Shadow DOM Behavior
    /// - If event.composed = false, shadow roots act as barriers
    /// - Nodes inside closed shadow roots are hidden from external listeners
    /// - The path is adjusted based on where the listener is attached
    ///
    /// ## Parameters
    /// - `allocator`: Allocator for the returned path array
    ///
    /// ## Returns
    /// ArrayList of EventTarget pointers representing the event path.
    /// Caller owns the returned ArrayList and must call deinit().
    ///
    /// ## Example
    /// ```zig
    /// var event = Event.init("click", .{ .bubbles = true, .composed = true });
    /// // ... dispatch event ...
    /// const path = try event.composedPath(allocator);
    /// defer path.deinit();
    /// for (path.items) |target| {
    ///     // Process each target in the path
    /// }
    /// ```
    ///
    /// ## Spec References
    /// - Algorithm: https://dom.spec.whatwg.org/#dom-event-composedpath
    /// - WebIDL: /Users/bcardarella/projects/webref/ed/idl/dom.idl:48
    pub fn composedPath(self: *const Event, allocator: Allocator) !std.ArrayList(*anyopaque) {
        var result = std.ArrayList(*anyopaque){};
        errdefer result.deinit(allocator);

        // If no event path was computed (event not dispatched), return empty
        if (self.event_path == null) {
            return result;
        }

        // For Phase 4 initial implementation: Return full event path
        // Future: Implement shadow DOM boundary filtering based on:
        // - event.composed flag
        // - currentTarget position relative to shadow roots
        // - Shadow root mode (open vs closed)
        const path = self.event_path.?;
        try result.appendSlice(allocator, path.items);

        return result;
    }

    /// Cleans up event path (called after dispatch completes).
    ///
    /// Internal method - not part of WebIDL interface.
    /// Should be called by dispatchEvent() after event propagation completes.
    pub fn clearEventPath(self: *Event, allocator: Allocator) void {
        if (self.event_path) |*path| {
            path.deinit(allocator);
            self.event_path = null;
        }
    }
};

/// Options for creating an Event.
///
/// Implements WHATWG DOM EventInit dictionary per ยง2.2.
///
/// ## WebIDL
/// ```webidl
/// dictionary EventInit {
///   boolean bubbles = false;
///   boolean cancelable = false;
///   boolean composed = false;
/// };
/// ```
///
/// ## Spec References
/// - WebIDL: /Users/bcardarella/projects/webref/ed/idl/dom.idl:54-58
pub const EventInit = struct {
    /// Whether event bubbles up through ancestors
    bubbles: bool = false,

    /// Whether event can be canceled with preventDefault()
    cancelable: bool = false,

    /// Whether event crosses shadow DOM boundary
    composed: bool = false,
};

// ============================================================================
// TESTS
// ============================================================================













